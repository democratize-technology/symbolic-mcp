# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Symbolic MCP Contributors

name: Dependabot PR Management

on:
  pull_request:
    types: [opened, synchronize, labeled, unlabeled]
  pull_request_review:
    types: [submitted, edited, dismissed]

jobs:
  # === PR LABELING AND CATEGORIZATION ===
  categorize-dependabot-pr:
    name: üè∑Ô∏è Categorize Dependabot PR
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Categorize PR based on content
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const title = pr.title;
            const body = pr.body || '';
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const changedFiles = files.data.map(f => f.filename);

            // Determine labels based on PR content
            const labels = [];

            // Basic dependency label
            labels.push('dependencies');

            // Categorize by title prefix
            if (title.startsWith('security')) {
              labels.push('security');
            } else if (title.startsWith('chore')) {
              labels.push('chore');
            } else if (title.startsWith('ci')) {
              labels.push('ci-cd');
            } else if (title.startsWith('docker')) {
              labels.push('docker');
            }

            // Categorize by dependency type
            if (body.includes('fastmcp') || title.includes('fastmcp')) {
              labels.push('mcp-framework');
            }
            if (body.includes('z3-solver') || title.includes('z3')) {
              labels.push('smt-solver');
            }
            if (body.includes('crosshair') || title.includes('crosshair')) {
              labels.push('symbolic-execution');
            }
            if (body.includes('RestrictedPython') || title.includes('restricted')) {
              labels.push('security-sandbox');
            }
            if (body.includes('pytest') || title.includes('pytest')) {
              labels.push('testing');
            }
            if (body.includes('bandit') || body.includes('safety') || title.includes('security')) {
              labels.push('security-tools');
            }

            // Categorize by update type
            if (title.includes('patch')) {
              labels.push('patch-update');
            } else if (title.includes('minor')) {
              labels.push('minor-update');
            } else if (title.includes('major')) {
              labels.push('major-update');
            }

            // Categorize by ecosystem
            if (changedFiles.some(f => f.includes('requirements.txt') || f.includes('pyproject.toml'))) {
              labels.push('python');
            }
            if (changedFiles.some(f => f.includes('.github/workflows'))) {
              labels.push('github-actions');
            }
            if (changedFiles.some(f => f.includes('Dockerfile') || f.includes('docker'))) {
              labels.push('docker');
            }

            // Auto-merge eligibility
            const isPatchUpdate = title.includes('patch') || !title.includes('major') && !title.includes('minor');
            const isSecurityUpdate = title.includes('security') || labels.includes('security');
            const isCoreDependency = labels.includes('mcp-framework') || labels.includes('symbolic-execution') || labels.includes('security-sandbox');

            if ((isSecurityUpdate && isPatchUpdate) || (isPatchUpdate && !isCoreDependency)) {
              labels.push('auto-merge');
            }

            // Priority assessment
            if (isSecurityUpdate) {
              labels.push('priority-high');
            } else if (isCoreDependency) {
              labels.push('priority-medium');
            } else {
              labels.push('priority-low');
            }

            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labels
              });

              console.log(`Applied labels: ${labels.join(', ')}`);
            }

      - name: Add descriptive PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Skip if we already commented
            if (comments.some(c => c.user.login === 'github-actions[bot]' && c.body.includes('üìã Dependabot PR Analysis'))) {
              console.log('Already commented on this PR');
              return;
            }

            const title = pr.title;
            const body = pr.body || '';

            // Analyze PR content
            const analysis = {
              updateType: 'unknown',
              securityImpact: 'unknown',
              stabilityImpact: 'unknown',
              autoMerge: false
            };

            if (title.includes('patch')) {
              analysis.updateType = 'patch';
            } else if (title.includes('minor')) {
              analysis.updateType = 'minor';
            } else if (title.includes('major')) {
              analysis.updateType = 'major';
            }

            if (title.includes('security') || body.includes('CVE') || body.includes('vulnerability')) {
              analysis.securityImpact = 'high';
            } else if (body.includes('bandit') || body.includes('safety')) {
              analysis.securityImpact = 'medium';
            }

            if (title.includes('fastmcp') || title.includes('z3-solver') || title.includes('crosshair')) {
              analysis.stabilityImpact = 'high';
            }

            analysis.autoMerge = analysis.updateType === 'patch' || (analysis.updateType === 'minor' && analysis.securityImpact === 'medium');

            const comment = `# üìã Dependabot PR Analysis

## üîç Update Details
- **Type:** ${analysis.updateType} version update
- **Security Impact:** ${analysis.securityImpact}
- **Stability Impact:** ${analysis.stabilityImpact}

## üöÄ Auto-Merge Status
${analysis.autoMerge ? '‚úÖ **Eligible for auto-merge**' : '‚è∏Ô∏è **Manual review required**'}

${analysis.autoMerge ?
  'This PR will be automatically merged if all checks pass and no "stop-auto-merge" label is added.' :
  'Please review this PR carefully before merging.'
}

## üìä Review Checklist
- [ ] All CI checks pass
- [ ] Security scans show no new vulnerabilities
- [ ] Update maintains compatibility with symbolic execution engine
- [ ] Documentation updates if needed (for major/minor updates)
- [ ] Test coverage remains adequate

## üè∑Ô∏è Applied Labels
This PR has been automatically labeled based on its content for better organization and prioritization.

---
*Automated analysis by Dependabot PR Management workflow*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # === REVIEW ASSIGNMENT ===
  assign-reviewers:
    name: üë• Assign Reviewers
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    permissions:
      pull-requests: write

    steps:
      - name: Assign appropriate reviewers
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const title = pr.title;
            const body = pr.body || '';

            // Determine reviewer assignment based on PR type
            let reviewers = ['jpwoody']; // Default reviewer

            // Additional reviewers based on content
            if (title.includes('security') || body.includes('CVE')) {
              // For security updates, always assign to main maintainer
              console.log('Security update - assigning to main maintainer');
            }

            if (title.includes('experimental') || body.includes('angr') || body.includes('ray')) {
              // For experimental features, consider additional reviewers
              console.log('Experimental feature update');
            }

            // Assign reviewer (only if not already assigned)
            if (pr.requested_reviewers.length === 0) {
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                reviewers: reviewers
              });

              console.log(`Assigned reviewers: ${reviewers.join(', ')}`);
            } else {
              console.log('Reviewers already assigned');
            }

  # === PR VALIDATION ===
  validate-dependabot-pr:
    name: ‚úÖ Validate Dependabot PR
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' }}
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Validate dependency changes
        run: |
          echo "üîç Validating dependency changes..."

          # Check what files were changed
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)

          echo "Changed files: $CHANGED_FILES"

          # Validate changes are appropriate
          INVALID_CHANGES=false
          WARNINGS=()

          for file in $CHANGED_FILES; do
            case $file in
              requirements.txt|pyproject.toml|setup.py|setup.cfg)
                echo "‚úÖ Valid dependency file: $file"
                ;;
              .github/workflows/*.yml)
                echo "‚úÖ Valid workflow file: $file"
                ;;
              Dockerfile|docker-compose*.yml)
                echo "‚úÖ Valid Docker file: $file"
                ;;
              *)
                echo "‚ö†Ô∏è Unexpected file changed: $file"
                WARNINGS+=("Unexpected file changed: $file")
                ;;
            esac
          done

          # Validate version constraints in dependency files
          if [[ -f "requirements.txt" ]]; then
            echo "üîç Validating requirements.txt..."

            # Check for pinned versions (should allow some flexibility)
            while read -r line; do
              if [[ "$line" =~ ^[a-zA-Z0-9\-_]+==[0-9] ]]; then
                echo "‚ö†Ô∏è Pinned version detected: $line"
                WARNINGS+=("Consider using version ranges instead of pinned versions")
              fi
            done < requirements.txt
          fi

          if [[ -f "pyproject.toml" ]]; then
            echo "üîç Validating pyproject.toml..."

            # Check for version constraints on critical dependencies
            python -c "
          import sys
          try:
              with open('pyproject.toml', 'r') as f:
                  content = f.read()

              critical_deps = ['fastmcp', 'z3-solver', 'RestrictedPython']
              issues = []

              for dep in critical_deps:
                  if dep in content:
                      # Check if there's a version constraint
                      import re
                      pattern = rf'{dep}.*[<>=!].*[0-9]'
                      if not re.search(pattern, content):
                          issues.append(f'Missing version constraint for {dep}')

              if issues:
                  print('‚ö†Ô∏è Version constraint issues:')
                  for issue in issues:
                      print(f'  - {issue}')
                  sys.exit(1)
              else:
                  print('‚úÖ All critical dependencies have version constraints')

          except FileNotFoundError:
              print('‚ö†Ô∏è No pyproject.toml found')
              sys.exit(1)
          except Exception as e:
              print(f'‚ö†Ô∏è Error validating pyproject.toml: {e}')
              sys.exit(1)
          "
          fi

          # Output validation result
          if [[ $INVALID_CHANGES == true ]]; then
            echo "‚ùå Validation failed - invalid changes detected"
            exit 1
          elif [[ ${#WARNINGS[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è Validation passed with warnings"
            for warning in "${WARNINGS[@]}"; do
              echo "  - $warning"
            done
          else
            echo "‚úÖ Validation passed - all changes are appropriate"
          fi

      - name: Add validation comment
        if: failure() || success()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read validation status from previous step
            // This is a simplified approach - in practice you'd pass this between steps
            const validationStatus = process.exitCode === 0 ? 'passed' : 'failed';

            const comment = `# üîç Dependabot PR Validation

## Validation Status: ${validationStatus === 'passed' ? '‚úÖ PASSED' : '‚ùå FAILED'}

${validationStatus === 'passed' ?
  'All dependency changes have been validated and appear appropriate.' :
  'Some issues were detected during validation. Please review the changes carefully.'
}

## Validation Checks Performed
- [x] File change validation (only dependency files should be changed)
- [x] Version constraint validation (critical dependencies should have constraints)
- [x] Configuration integrity check

## Next Steps
${validationStatus === 'passed' ?
  'PR looks good for review and potential auto-merge.' :
  'Please review the validation failures and address any issues.'
}

---
*Automated validation by Dependabot PR Management workflow*`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  # === LABEL MANAGEMENT ===
  manage-labels:
    name: üè∑Ô∏è Manage Labels
    runs-on: ubuntu-latest
    if: ${{ github.actor == 'dependabot[bot]' && (github.event.action == 'labeled' || github.event.action == 'unlabeled') }}
    permissions:
      issues: write
      pull-requests: write

    steps:
      - name: Handle stop-auto-merge label
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const labels = pr.labels.map(l => l.name);
            const hasStopAutoMerge = labels.includes('stop-auto-merge');
            const hasAutoMerge = labels.includes('auto-merge');

            // Remove conflicting labels
            if (hasStopAutoMerge && hasAutoMerge) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'auto-merge'
              });

              console.log('Removed auto-merge label due to stop-auto-merge');
            }

            // Add comment about label change
            if (github.event.action === 'labeled' && github.event.label.name === 'stop-auto-merge') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: 'üõë **Auto-merge blocked** - This PR will not be auto-merged due to the `stop-auto-merge` label.'
              });
            }