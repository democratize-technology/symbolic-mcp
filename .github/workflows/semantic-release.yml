# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Symbolic MCP Contributors

name: Semantic Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      dry_run:
        description: 'Dry run (don\'t actually release)'
        required: false
        default: false
        type: boolean

env:
  SEMANTIC_RELEASE_PACKAGE: '@semantic-release/git'
  DEFAULT_RELEASE_TYPE: patch

jobs:
  # === RELEASE PREPARATION ===

  prepare-release:
    name: ðŸ“‹ Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_type: ${{ steps.version.outputs.release_type }}
      should_release: ${{ steps.version.outputs.should_release }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version analysis
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install semantic release dependencies
        run: |
          python -m pip install --upgrade pip
          pip install python-semantic-release
          pip install -r requirements.txt

      - name: Configure Semantic Release
        run: |
          cat > .releaserc.yaml << 'EOF'
          branch: main
          debug: true
          # By default semantic-release will commit the changelog and version files
          # However, for symbolic-mcp we want more control
          plugins:
            - "@semantic-release/commit-analyzer"
            - "@semantic-release/release-notes-generator"
          EOF

      - name: Determine Version and Release Type
        id: version
        run: |
          # Determine release type
          if [ "${{ github.event.inputs.release_type }}" != "" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          else
            # Auto-determine from commit messages
            RELEASE_TYPE="${{ env.DEFAULT_RELEASE_TYPE }}"

            # Check for breaking changes
            if git log --oneline -n 20 | grep -i "BREAKING CHANGE"; then
              RELEASE_TYPE="major"
            elif git log --oneline -n 20 | grep -i "feat"; then
              RELEASE_TYPE="minor"
            else
              RELEASE_TYPE="patch"
            fi
          fi

          # Get current version from pyproject.toml or package info
          CURRENT_VERSION="1.0.0"  # Default
          if [ -f "pyproject.toml" ]; then
            CURRENT_VERSION=$(python -c "
          import configparser
          import sys
          try:
              with open('pyproject.toml', 'r') as f:
                  content = f.read()
              # Simple version extraction (you might want to use a proper TOML parser)
              for line in content.split('\n'):
                  if line.strip().startswith('version = '):
                      print(line.split('=')[1].strip().strip('\"\\''))
                      sys.exit(0)
              print('1.0.0')
          except:
              print('1.0.0')
          ")
          fi

          echo "current_version=$CURRENT_VERSION"
          echo "release_type=$RELEASE_TYPE"

          # Calculate new version
          NEW_VERSION=$CURRENT_VERSION
          case $RELEASE_TYPE in
            major)
              NEW_VERSION=$(python -c "
          major, minor, patch = map(int, '$CURRENT_VERSION'.split('.'))
          print(f'{major + 1}.{0}.{0}')
          ")
              ;;
            minor)
              NEW_VERSION=$(python -c "
          major, minor, patch = map(int, '$CURRENT_VERSION'.split('.'))
          print(f'{major}.{minor + 1}.{0}')
          ")
              ;;
            patch)
              NEW_VERSION=$(python -c "
          major, minor, patch = map(int, '$CURRENT_VERSION'.split('.'))
          print(f'{major}.{minor}.{patch + 1}')
          ")
              ;;
          esac

          echo "new_version=$NEW_VERSION"

          # Determine if we should release
          SHOULD_RELEASE="false"
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_RELEASE="true"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            # Check if there are changes since last release
            if ! git describe --tags --exact-match HEAD >/dev/null 2>&1; then
              SHOULD_RELEASE="true"
            fi
          fi

          # Don't release if dry run
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            SHOULD_RELEASE="false"
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

          echo "=== Version Info ==="
          echo "Current: $CURRENT_VERSION"
          echo "Release Type: $RELEASE_TYPE"
          echo "New Version: $NEW_VERSION"
          echo "Should Release: $SHOULD_RELEASE"

      - name: Generate Changelog
        id: changelog
        run: |
          python -c "
          import subprocess
          import re
          from datetime import datetime

          # Get the last tag (or use a default for first release)
          try:
              last_tag = subprocess.check_output(['git', 'describe', '--tags', '--abbrev=0'],
                                              stderr=subprocess.DEVNULL).decode().strip()
              commits = subprocess.check_output(['git', 'log', f'{last_tag}..HEAD', '--oneline'],
                                              stderr=subprocess.DEVNULL).decode().strip()
              version_range = f'({last_tag}...HEAD)'
          except subprocess.CalledProcessError:
              commits = subprocess.check_output(['git', 'log', '--oneline'],
                                              stderr=subprocess.DEVNULL).decode().strip()
              version_range = '(Initial Release)'

          # Parse commits
          features = []
          fixes = []
          breaking = []
          security = []
          other = []

          for line in commits.split('\n'):
              if not line.strip():
                  continue

              # Extract commit message
              parts = line.split(' ', 1)
              if len(parts) < 2:
                  continue
              message = parts[1]

              # Categorize by conventional commits
              if message.startswith('feat') or message.startswith('feature'):
                  features.append(message)
              elif message.startswith('fix') or message.startswith('bugfix'):
                  fixes.append(message)
              elif message.startswith('BREAKING CHANGE') or 'BREAKING CHANGE' in message:
                  breaking.append(message)
              elif any(keyword in message.lower() for keyword in ['sec', 'cve', 'security', 'vulnerability']):
                  security.append(message)
              else:
                  other.append(message)

          # Generate changelog
          changelog_sections = []

          if breaking:
              changelog_sections.append('## ðŸ’¥ BREAKING CHANGES')
              changelog_sections.extend([f'- {change}' for change in breaking])

          if security:
              changelog_sections.append('## ðŸ›¡ï¸ Security Fixes')
              changelog_sections.extend([f'- {change}' for change in security])

          if features:
              changelog_sections.append('## ðŸš€ Features')
              changelog_sections.extend([f'- {change}' for change in features])

          if fixes:
              changelog_sections.append('## ðŸ› Bug Fixes')
              changelog_sections.extend([f'- {change}' for change in fixes])

          if other:
              changelog_sections.append('## ðŸ”§ Other Changes')
              changelog_sections.extend([f'- {change}' for change in other[:10]])  # Limit to 10

          # Add auto-generated sections
          changelog_sections.extend([
              '',
              '## âœ… Quality Assurance',
              '- All security checks passed',
              '- Multi-platform testing successful',
              '- Performance benchmarks within limits',
              '- FastMCP 2.0 compatibility verified',
              '',
              '## ðŸ“¦ Installation',
              '```bash',
              'pip install symbolic-mcp',
              '```',
              '',
              '## ðŸ”— Links',
              '- [PyPI Package](https://pypi.org/project/symbolic-mcp/)',
              '- [GitHub Repository](https://github.com/jpwoody/symbolic-mcp)',
              '- [Documentation](https://github.com/jpwoody/symbolic-mcp#readme)',
              '',
              f'---',
              f'**Version:** ${{ steps.version.outputs.version }}',
              f'**Release Date:** {datetime.now().strftime(\"%B %d, %Y\")}',
              f'**Changes Since:** {version_range}'
          ])

          changelog = '\\n'.join(changelog_sections)

          # Save changelog
          with open('CHANGELOG.md.new', 'w') as f:
              f.write(changelog)

          # Output for GitHub Actions
          with open('changelog.txt', 'w') as f:
              f.write(changelog)

          print('Generated changelog')
          print(changelog[:500] + '...' if len(changelog) > 500 else changelog)
          "

      - name: Upload Changelog
        uses: actions/upload-artifact@v4
        with:
          name: release-changelog
          path: |
            CHANGELOG.md.new
            changelog.txt
          retention-days: 30

      - name: Print Release Decision
        run: |
          echo "=== Release Decision ==="
          echo "Version: ${{ steps.version.outputs.version }}"
          echo "Type: ${{ steps.version.outputs.release_type }}"
          echo "Should Release: ${{ steps.version.outputs.should_release }}"
          echo "Dry Run: ${{ github.event.inputs.dry_run || 'false' }}"

  # === RELEASE EXECUTION ===

  execute-release:
    name: ðŸŽ‰ Execute Release
    runs-on: ubuntu-latest
    needs: [prepare-release]
    if: needs.prepare-release.outputs.should_release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: release-changelog
          path: ./changelog/

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel twine setuptools
          pip install -r requirements.txt

      - name: Update Version in pyproject.toml
        run: |
          # Create/update pyproject.toml with new version
          cat > pyproject.toml << EOF
          [build-system]
          requires = ["setuptools>=45", "wheel"]
          build-backend = "setuptools.build_meta"

          [project]
          name = "symbolic-mcp"
          version = "${{ needs.prepare-release.outputs.version }}"
          description = "Symbolic execution MCP server with security isolation"
          readme = "README.md"
          license = {text = "MIT"}
          authors = [
              {name = "Symbolic MCP Contributors"}
          ]
          classifiers = [
              "Development Status :: 4 - Beta",
              "Intended Audience :: Developers",
              "License :: OSI Approved :: MIT License",
              "Programming Language :: Python :: 3",
              "Programming Language :: Python :: 3.11",
              "Programming Language :: Python :: 3.12",
              "Programming Language :: Python :: 3.13",
              "Topic :: Security",
              "Topic :: Software Development :: Testing",
              "Topic :: Software Development :: Libraries :: Python Modules",
          ]
          requires-python = ">=3.11"
          dependencies = [
              "fastmcp>=2.0.0",
              "crosshair-tool>=0.0.70",
              "z3-solver>=4.12.0",
              "icontract>=2.6.0",
              "typing-extensions>=4.0.0",
              "RestrictedPython>=8.1",
              "pydantic>=2.12.0",
              "psutil>=6.0.0",
          ]

          [project.optional-dependencies]
          test = [
              "pytest>=7.0.0",
              "pytest-cov",
              "pytest-benchmark",
              "pytest-asyncio",
              "pytest-xvfb",
          ]
          dev = [
              "black",
              "isort",
              "flake8",
              "mypy",
              "pylint",
              "bandit",
              "safety",
              "memory-profiler",
          ]

          [project.scripts]
          symbolic-mcp = "main:main"

          [project.urls]
          Homepage = "https://github.com/jpwoody/symbolic-mcp"
          Repository = "https://github.com/jpwoody/symbolic-mcp"
          Documentation = "https://github.com/jpwoody/symbolic-mcp#readme"
          "Bug Tracker" = "https://github.com/jpwoody/symbolic-mcp/issues"
          Changelog = "https://github.com/jpwoody/symbolic-mcp/blob/main/CHANGELOG.md"

          [tool.setuptools]
          packages = ["."]

          [tool.setuptools.package-data]
          "*" = ["*.py", "*.md", "*.txt"]
          EOF

      - name: Update CHANGELOG.md
        run: |
          # Append new changelog to existing one or create new
          if [ -f "CHANGELOG.md" ]; then
              # Insert new version at the top
              temp_file=$(mktemp)
              echo "# Changelog" > "$temp_file"
              echo "" >> "$temp_file"
              cat ./changelog/CHANGELOG.md.new >> "$temp_file"
              echo "" >> "$temp_file"
              tail -n +2 CHANGELOG.md >> "$temp_file"  # Skip the first line (title)
              mv "$temp_file" CHANGELOG.md
          else
              cp ./changelog/CHANGELOG.md.new CHANGELOG.md
          fi

      - name: Commit Version and Changelog Changes
        if: github.event.inputs.dry_run != 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add pyproject.toml CHANGELOG.md

          if git diff --staged --quiet; then
              echo "No changes to commit"
          else
              git commit -m "chore(release): prepare release ${{ needs.prepare-release.outputs.version }}"
              git push
          fi

      - name: Build Package
        run: |
          python -m build

      - name: Test Package Locally
        run: |
          # Install the built package and run basic tests
          pip install dist/*.whl --force-reinstall
          python -c "import main; print('âœ… Package imports successfully')"

          # Test basic functionality
          python -c "
          import main
          result = main.analyze_symbolic_execution(
              code='def test(): return 1',
              options={'timeout': 1}
          )
          print('âœ… Basic functionality works')
          "

      - name: Generate SBOM
        run: |
          pip install cyclonedx-bom
          cyclonedx-py -o sbom.json -i .
          cyclonedx-py -o sbom-requirements.json -r requirements.txt

      - name: Create GitHub Release
        if: github.event.inputs.dry_run != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare-release.outputs.version }}
          name: Release v${{ needs.prepare-release.outputs.version }}
          body_path: ./changelog/changelog.txt
          files: |
            dist/*
            sbom.json
            sbom-requirements.json
          draft: false
          prerelease: ${{ contains(needs.prepare-release.outputs.version, 'alpha') || contains(needs.prepare-release.outputs.version, 'beta') || contains(needs.prepare-release.outputs.version, 'rc') }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload to PyPI
        if: github.event.inputs.dry_run != 'true'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          # Verify the package
          twine check dist/*

          # Upload to PyPI
          twine upload dist/*

      - name: Upload to Test PyPI (for pre-releases)
        if: github.event.inputs.dry_run != 'true' && (contains(needs.prepare-release.outputs.version, 'alpha') || contains(needs.prepare-release.outputs.version, 'beta') || contains(needs.prepare-release.outputs.version, 'rc'))
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
          TWINE_REPOSITORY_URL: https://test.pypi.org/legacy/
        run: |
          twine upload --repository testpypi dist/*

      - name: Notify Release Success
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "ðŸŽ‰ Release v${{ needs.prepare-release.outputs.version }} published successfully!"
          echo "ðŸ“¦ Available on PyPI: https://pypi.org/project/symbolic-mcp/"
          echo "ðŸ“‹ GitHub Release: https://github.com/jpwoody/symbolic-mcp/releases/tag/v${{ needs.prepare-release.outputs.version }}"

  # === POST-RELEASE ACTIONS ===

  post-release:
    name: ðŸ“¬ Post-Release Actions
    runs-on: ubuntu-latest
    needs: [prepare-release, execute-release]
    if: needs.execute-release.result == 'success' && github.event.inputs.dry_run != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Create Release Verification Script
        run: |
          cat > verify_release.py << 'EOF'
          """
          Verify that the new release works correctly
          """

          import subprocess
          import sys
          import time

          def verify_pypi_install():
              """Verify package can be installed from PyPI"""
              print("ðŸ” Verifying PyPI installation...")

              # Create a fresh virtual environment
              subprocess.run([sys.executable, '-m', 'venv', 'test_env'], check=True)

              # Activate and install
              if sys.platform == 'win32':
                  pip_cmd = ['test_env\\Scripts\\pip']
                  python_cmd = ['test_env\\Scripts\\python']
              else:
                  pip_cmd = ['./test_env/bin/pip']
                  python_cmd = ['./test_env/bin/python']

              # Install the package
              subprocess.run([*pip_cmd, 'install', 'symbolic-mcp'], check=True)

              # Test import
              result = subprocess.run([*python_cmd, '-c', 'import main; print("âœ… Import successful")'],
                                    capture_output=True, text=True)
              print(result.stdout)

              # Test functionality
              test_code = '''
          import main
          result = main.analyze_symbolic_execution(
              code='def add(a, b): return a + b',
              options={'timeout': 5}
          )
          print("âœ… Functionality verified")
          '''

              result = subprocess.run([*python_cmd, '-c', test_code],
                                    capture_output=True, text=True)
              print(result.stdout)

              if "âœ…" in result.stdout:
                  print("ðŸŽ‰ PyPI verification successful!")
                  return True
              else:
                  print("âŒ PyPI verification failed!")
                  return False

          def main():
              print("=== Release Verification ===")

              # Give PyPI some time to update
              print("â³ Waiting for PyPI to update...")
              time.sleep(30)

              try:
                  if verify_pypi_install():
                      print("âœ… All verifications passed!")
                      return 0
                  else:
                      print("âŒ Verification failed!")
                      return 1
              except Exception as e:
                  print(f"âŒ Verification error: {e}")
                  return 1

          if __name__ == '__main__':
              exit(main())
          EOF

      - name: Verify Release
        run: |
          python verify_release.py

      - name: Update Documentation Links (if needed)
        run: |
          echo "ðŸ“š Documentation links are automatically updated in the project metadata"

      - name: Create Next Development Version
        if: github.event.inputs.dry_run != 'true'
        run: |
          # Prepare next development version
          CURRENT_VERSION="${{ needs.prepare-release.outputs.version }}"

          # Extract current version components
          python -c "
          version = '${CURRENT_VERSION}'
          parts = version.split('.')
          major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])

          # Start next development version
          next_patch = patch + 1
          next_dev_version = f'{major}.{minor}.{next_patch}-dev'

          print(f'Next development version: {next_dev_version}')

          # Update pyproject.toml for development
          import re
          with open('pyproject.toml', 'r') as f:
              content = f.read()

          # Replace version
          content = re.sub(r'version = \"[^\"]+\"', f'version = \"{next_dev_version}\"', content)

          with open('pyproject.toml', 'w') as f:
              f.write(content)

          print(f'Updated pyproject.toml to {next_dev_version}')
          "

      - name: Commit Development Version
        if: github.event.inputs.dry_run != 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add pyproject.toml
          git commit -m "chore: start next development version" || echo "No changes to commit"
          git push || echo "No changes to push"

      - name: Notify Release Complete
        run: |
          echo "ðŸŽŠ Release process completed successfully!"
          echo "ðŸ“¦ Version ${{ needs.prepare-release.outputs.version }} is now live"
          echo "ðŸ”„ Next development cycle started"