#!/usr/bin/env python3
"""
Version Synchronization Script

This script synchronizes version information across:
- pyproject.toml
- Source code version constants
- Package metadata
- Git tags (for releases)
"""

import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

import re

from version_manager import VersionManager


def sync_version_to_main_py(version_manager: VersionManager, version_str: str) -> bool:
    """Sync version to main.py module"""
    main_py = Path(__file__).parent.parent / "main.py"

    if not main_py.exists():
        print(f"Warning: {main_py} not found")
        return False

    try:
        content = main_py.read_text()

        # Update or add __version__ variable
        if "__version__" in content:
            # Update existing version
            lines = content.split("\n")
            for i, line in enumerate(lines):
                if line.strip().startswith("__version__"):
                    lines[i] = f'__version__ = "{version_str}"'
                    break
            content = "\n".join(lines)
        else:
            # Add version after imports
            import_end = 0
            lines = content.split("\n")
            for i, line in enumerate(lines):
                if line.startswith("import ") or line.startswith("from "):
                    import_end = i + 1
                elif not line.strip() and import_end > 0:
                    break

            lines.insert(import_end + 1, f"")
            lines.insert(import_end + 2, f'__version__ = "{version_str}"')
            content = "\n".join(lines)

        main_py.write_text(content)
        print(f"‚úÖ Updated main.py version to {version_str}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to update main.py: {e}")
        return False


def sync_version_to_setup_py(version_manager: VersionManager, version_str: str) -> bool:
    """Sync version to setup.py (if it exists)"""
    setup_py = Path(__file__).parent.parent / "setup.py"

    if not setup_py.exists():
        print(f"‚ÑπÔ∏è  setup.py not found (not required)")
        return True

    try:
        content = setup_py.read_text()

        # Update version in setup() call
        lines = content.split("\n")
        for i, line in enumerate(lines):
            if "version=" in line and not line.strip().startswith("#"):
                lines[i] = f'    version="{version_str}",'
                break

        setup_py.write_text("\n".join(lines))
        print(f"‚úÖ Updated setup.py version to {version_str}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to update setup.py: {e}")
        return False


def create_version_py(version_manager: VersionManager, version_str: str) -> bool:
    """Create _version.py file with setuptools-scm compatibility"""
    version_py = Path(__file__).parent.parent / "_version.py"

    try:
        content = f'''# Version file generated by setuptools-scm
"""Version information for symbolic-mcp"""

__version__ = "{version_str}"

# Version metadata
version_info = {{
    "version": "{version_str}",
    "git_version": "{version_manager.get_git_version()}",
    "is_git_repo": {version_manager.is_git_repository()},
}}

# Compatibility information
try:
    from .version_manager import VersionManager
    vm = VersionManager()
    fastmcp_compatibility = vm.get_fastmcp_compatibility()
except ImportError:
    fastmcp_compatibility = {{
        "version": "unknown",
        "compatibility": "unknown",
        "message": "FastMCP not available",
        "required": ">=2.0.0"
    }}

__fastmcp_compatibility__ = fastmcp_compatibility
'''

        version_py.write_text(content)
        print(f"‚úÖ Created _version.py with version {version_str}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to create _version.py: {e}")
        return False


def update_documentation_versions(
    version_manager: VersionManager, version_str: str
) -> bool:
    """Update version references in documentation"""
    docs_dir = Path(__file__).parent.parent / "docs"
    readme = Path(__file__).parent.parent / "README.md"

    success = True

    # Update README.md
    if readme.exists():
        try:
            content = readme.read_text()

            # Update version in installation instructions
            content = re.sub(
                r"pip install symbolic-mcp==[0-9]+\.[0-9]+\.[0-9]+[^\\s]*",
                f"pip install symbolic-mcp=={version_str}",
                content,
            )

            readme.write_text(content)
            print(f"‚úÖ Updated README.md version references")
        except Exception as e:
            print(f"‚ùå Failed to update README.md: {e}")
            success = False

    # Update documentation files
    if docs_dir.exists():
        for doc_file in docs_dir.glob("**/*.md"):
            try:
                content = doc_file.read_text()

                # Update version references
                content = re.sub(
                    r"symbolic-mcp==[0-9]+\.[0-9]+\.[0-9]+[^\\s]*",
                    f"symbolic-mcp=={version_str}",
                    content,
                )

                doc_file.write_text(content)

            except Exception:
                continue  # Skip files that can't be processed

    return success


def main():
    """Main version synchronization function"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Synchronize version across project files"
    )
    parser.add_argument("--version", required=True, help="Version string to sync")
    parser.add_argument(
        "--skip-main", action="store_true", help="Skip updating main.py"
    )
    parser.add_argument(
        "--skip-docs", action="store_true", help="Skip updating documentation"
    )

    args = parser.parse_args()

    version_manager = VersionManager()

    # Validate version
    if not version_manager.validate_version(args.version):
        print(f"‚ùå Invalid version format: {args.version}")
        return 1

    print(f"üîÑ Synchronizing version {args.version} across project files...")

    success = True

    # Update pyproject.toml
    if not version_manager.set_pyproject_version(args.version):
        print("‚ùå Failed to update pyproject.toml")
        success = False
    else:
        print("‚úÖ Updated pyproject.toml")

    # Update main.py
    if not args.skip_main:
        if not sync_version_to_main_py(version_manager, args.version):
            success = False

    # Create _version.py
    if not create_version_py(version_manager, args.version):
        success = False

    # Update setup.py (if exists)
    if not sync_version_to_setup_py(version_manager, args.version):
        success = False

    # Update documentation
    if not args.skip_docs:
        if not update_documentation_versions(version_manager, args.version):
            print("‚ö†Ô∏è  Some documentation files could not be updated")

    if success:
        print(f"üéâ Version synchronization completed successfully!")
        return 0
    else:
        print("‚ùå Version synchronization completed with errors")
        return 1


if __name__ == "__main__":
    sys.exit(main())
