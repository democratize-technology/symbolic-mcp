"""
SPDX-License-Identifier: MIT
Copyright (c) 2025 Symbolic MCP Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

"""
Security test demonstrating the critical sys.modules bypass vulnerability.

This test shows how the current RestrictedImporter allows bypassing security controls
by accessing pre-loaded modules in sys.modules.

CVSS 9.1 CRITICAL: Import bypass vulnerability allows full system access.
"""
import sys
import pytest
import tempfile
import importlib.util
import os

# Import the actual RestrictedImporter from main.py
from main import RestrictedImporter

def test_sys_modules_bypass_vulnerability():
    """
    SECURITY TEST: Demonstrates the critical sys.modules bypass vulnerability.

    Attack path:
    1. Python runtime loads 'sys', 'os', and other modules during startup
    2. Attacker submits code: import sys; sys.modules['subprocess'].run(['rm', '-rf', '/'])
    3. RestrictedImporter sees 'sys' is already loaded and allows import
    4. Attacker gains full system access through pre-loaded modules

    This test proves the vulnerability exists by:
    1. Showing blocked modules are in sys.modules (pre-loaded)
    2. Proving the current implementation allows bypassing imports
    3. Demonstrating access to dangerous functionality via bypass
    """
    # Step 1: Verify blocked modules are pre-loaded in sys.modules (attack prerequisite)
    blocked_modules_in_sys_modules = [
        module for module in RestrictedImporter.BLOCKED_MODULES
        if module in sys.modules
    ]

    assert len(blocked_modules_in_sys_modules) > 0, "Test requires pre-loaded blocked modules"
    assert 'sys' in blocked_modules_in_sys_modules, "sys module should be pre-loaded"
    assert 'os' in blocked_modules_in_sys_modules, "os module should be pre-loaded"

    # Step 2: Install the vulnerable RestrictedImporter
    RestrictedImporter.install()
    original_meta_path = sys.meta_path.copy()

    try:
        # Step 3: Attempt to import blocked modules that are pre-loaded
        # These should be blocked but are allowed due to the vulnerability

        # Test direct import of sys (should be blocked but isn't)
        import sys as sys_module  # This should fail but doesn't due to sys.modules check
        assert sys_module is not None, "sys module was imported (vulnerability confirmed)"

        # Test direct import of os (should be blocked but isn't)
        import os as os_module  # This should fail but doesn't due to sys.modules check
        assert os_module is not None, "os module was imported (vulnerability confirmed)"

        # Step 4: Demonstrate dangerous functionality via bypass
        # Prove we can access system-level operations through the bypass
        assert hasattr(sys_module, 'modules'), "sys.modules access available"
        assert hasattr(os_module, 'system'), "os.system access available"
        assert hasattr(os_module, 'remove'), "os.remove access available"

        # Step 5: Test submodule access (also vulnerable)
        try:
            # This should fail because subprocess isn't loaded
            import subprocess
            assert subprocess is not None, "subprocess also bypassed (extended vulnerability)"
        except ImportError:
            # Expected if subprocess isn't pre-loaded
            pass

    finally:
        # Cleanup: Restore original meta_path
        sys.meta_path = original_meta_path


def test_bypass_allows_system_access_simulation():
    """
    Simulates how an attacker would use the bypass for malicious purposes.
    This test shows the potential impact without actually doing harm.
    """
    # Install the vulnerable RestrictedImporter
    RestrictedImporter.install()

    try:
        # Attacker payload that would normally be blocked
        malicious_code_template = """
import sys
import os

# Check if we have sys access (should be blocked)
if hasattr(sys, 'modules'):
    # We have sys access - can now access ANY module in sys.modules
    dangerous_modules = [mod for mod in sys.modules.keys()
                        if any(dangerous in mod for dangerous in ['os', 'subprocess', 'shutil'])]

    # Check if we have os access (should be blocked)
    if hasattr(os, 'system'):
        # We have os.system access - can execute arbitrary commands
        # In a real attack: os.system('rm -rf /')
        pass
"""

        # Execute the attacker's code in a sandbox that should be restrictive
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(malicious_code_template)
            temp_path = f.name

        try:
            spec = importlib.util.spec_from_file_location("attacker_code", temp_path)
            module = importlib.util.module_from_spec(spec)

            # This should fail due to blocked imports, but succeeds due to vulnerability
            spec.loader.exec_module(module)

            # If we get here, the vulnerability is confirmed
            assert module is not None, "Attacker code executed successfully (vulnerability confirmed)"

        finally:
            os.unlink(temp_path)

    finally:
        RestrictedImporter.uninstall()


def test_non_preloaded_modules_still_blocked():
    """
    Verify that modules not in sys.modules are still properly blocked.
    This shows the vulnerability is specifically about pre-loaded modules.
    """
    # Install the vulnerable RestrictedImporter
    RestrictedImporter.install()

    try:
        # Test a module that's likely not pre-loaded
        # subprocess should not be in sys.modules initially
        if 'subprocess' not in sys.modules:
            # This should be blocked (and likely is)
            with pytest.raises(ImportError, match="Import of 'subprocess' is blocked"):
                import subprocess
        else:
            # If subprocess is pre-loaded, it would also be vulnerable
            # This demonstrates the scope of the vulnerability
            import subprocess
            assert subprocess is not None, "subprocess also vulnerable if pre-loaded"

    finally:
        RestrictedImporter.uninstall()